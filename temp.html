<h1>Using Nvidia Containers on Perceptron</h1>

<p>The goal of this document is to give users a quick tutorial demonstrating how
to take an existing deep learning project and run it on Perceptron in a GPU-
accelerated Docker container.</p>

<p>If you&rsquo;re in a hurry, the TL;DR is at the bottom.</p>

<h2>Getting Started</h2>

<p>Containers are like VMs with a lot less low-level isolation and security
guarantees. Instead of keeping multiple deep-learning libraries up to date,
you pull all your dependencies into an &ldquo;image&rdquo; which is then executed in
Nvidia&rsquo;s runtime environment. &ldquo;Containerizing&rdquo; an existing project can be
broken down into three main steps:</p>

<ol>
<li>Find the correct base container on Nvidia&rsquo;s Container Registry</li>
<li>Configure the build process for your project</li>
<li>Load your image into the Container runtime</li>
</ol>


<p>As an example, I&rsquo;ll be walking through this process with my own project</p>

<h2>Step 1: Getting Pull Access to NGC Container Registry (NCR)</h2>

<p>Many high level programming languages have some library/module index on
the Internet to facilitate code sharing (Python&rsquo;s PyPI, Ruby&rsquo;s Gem system, etc.).
In the world of containers, the eqiuvalent service is provided through container
registries. The registry that interests us the most is the <a href="https://ngc.nvidia.com/containers">Nvidia GPU Cloud Container Registry</a> (NCR).</p>

<p><strong>NOTE</strong>: You may have to create an NGC account and add your API key to get
pull access from the registry. Also, if you&rsquo;re tech stack is the same as the
one in the tutorial, you won&rsquo;t have to run any commands in this step.</p>

<p>Nvidia provides all of the &ldquo;Base images&rdquo;. You can search for the right
container through the web UI. Since my project is written in Python 3 and
depends on Tensorflow, I&rsquo;ll be using <a href="https://ngc.nvidia.com/catalog/containers/nvidia:tensorflow">this</a>
container. Note that there are different versions of similar builds in the
&ldquo;Tags&rdquo; tab on the WebUI. I&rsquo;ve gone ahead and pulled the latest version of
my desired image with the command:</p>

<p><code>docker pull nvcr.io/nvidia/tensorflow:19.01-py3</code></p>

<p>Some of these base images are quite large and take some time to download, so
if you want a different image I highly recommend you go pull it now while
you&rsquo;re reading this. If you&rsquo;d like to see a list of docker base images that
have already been pulled to Perceptron, go ahead and run:</p>

<p><code>docker image ls</code></p>

<p>Once you have the base image extracted into our local container registry, we&rsquo;re
ready to move on to the next step. In case you were curious, pulling a base image
that has already been downloaded to the machine just updates the image.</p>

<hr />

<h2>Step 2: Configuring the Build Process For Your Project&rsquo;s Container</h2>

<p>If you&rsquo;ve got this far, you ought to know what base image has the dependencies
you need. If it hasn&rsquo;t been pulled, it will get pulled when your container
gets build for the first time. Now that we have a desired base image for our
project, we can start specifying our build configuration through a Dockerfile.
A Dockerfile is a text file that lists all the commands in sequential order that
the Docker daemon must execute to build your container. The complete set of
Docker build commands is quite extensive, so I&rsquo;ve gone ahead and included my
annotated copy of my Dockerfile to cover the basics:</p>

<p>```</p>

<h1>Set Docker Base Image to pull from</h1>

<p>FROM nvcr.io/nvidia/tensorflow</p>

<h1>Create working directory for my application</h1>

<p>WORKDIR /app</p>

<h1>Copy the contents of the folder containing the Dockerfile into container&rsquo;s</h1>

<h1>working dir</h1>

<p>COPY . /app</p>

<h1>Set an environment variable called CUDA_VISIBLE_DEVICES in the container</h1>

<p>ENV CUDA_VISIBLE_DEVICES=PCI_BUS_ID</p>

<h1>Open Port 8000 for Tensorboard</h1>

<p>EXPOSE 8000</p>

<h1>Create a mount point for a directory that is shared between the container</h1>

<h1>and the host which  will persist after the contained application exits.</h1>

<h1>See: https://docs.docker.com/storage/volumes</h1>

<p>VOLUME &ldquo;/dataset&rdquo;</p>

<h1>Use RUN to execute shell commands that change the state of the container</h1>

<p>RUN pip install requirements.txt
```</p>

<p>For your convenience, I&rsquo;ve put this Dockerfile in this repository. Here is a
table of useful Dockerfile instructions for quick reference:</p>

<table>
<thead>
<tr>
<th> Command   </th>
<th> Calling Convention                                        </th>
<th> Purpose                                                                                                                       </th>
</tr>
</thead>
<tbody>
<tr>
<td> ARG       </td>
<td> ARG <Name>                                                </td>
<td> Add a custom argument to pass at build time                                                                                   </td>
</tr>
<tr>
<td> CMD       </td>
<td> CMD [<executable>, <arg1>, <arg2>, &hellip; <argv>]            </td>
<td> At Runtime, set default behavior to Launch executable with arguments.                                                         </td>
</tr>
<tr>
<td> COPY      </td>
<td> COPY [Source] [Container Destination]                     </td>
<td> Copy files over from host to container                                                                                        </td>
</tr>
<tr>
<td> EXPOSE    </td>
<td> EXPOSE <Port Number>                                      </td>
<td> Expose a virtual port from inside the container. To access from outside the Runtime, call <code>docker   run -p &lt;Port Number&gt;</code>     </td>
</tr>
<tr>
<td> FROM      </td>
<td> FROM <Image Name>                                         </td>
<td> Set base image                                                                                                                </td>
</tr>
<tr>
<td> RUN       </td>
<td> RUN <Shell Command>                                       </td>
<td> Run shell command inside container at build time and commit changes.                                                          </td>
</tr>
<tr>
<td> VOLUME    </td>
<td> VOLUME <Directory Name>                                   </td>
<td> Mount Docker volume in directory name                                                                                         </td>
</tr>
<tr>
<td> WORKDIR   </td>
<td> WORKDIR <Folder Name>                                     </td>
<td> Make container boot dir                                                                                                       </td>
</tr>
</tbody>
</table>


<p>You can find more information about creating Dockerfiles that fit your needs
in <a href="https://docs.docker.com/engine/reference/builder/">this</a> part of the
the official documentation.</p>
